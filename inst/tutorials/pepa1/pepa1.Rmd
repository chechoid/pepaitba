---
title: "Pensamiento Estad√≠stico en People Analytics"
author: "Arturo De Zan | Sergio Garcia Mora"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
library(funModeling)
library(tidyverse)
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)

# Cargamos los datos
kiwi_ar <- readRDS("kiwi_ar.RDS")


percentiles = profiling_num(kiwi_ar$sueldo_bruto)

p05 = percentiles[1,6]
p95 = percentiles[1,10]

kiwi_limpio = kiwi_ar %>% 
  filter(between(sueldo_bruto, p05, p95))

df_edad <- read.csv("edades.csv")
edades <- df_edad %>% select(Edad) %>% pull()
edades <- sort(edades)

```

## Pensamiento Estad√≠stico en People Analytics

![](https://youtu.be/Mz4GbMCqvcY){width="80%"}

Este es un tutorial interactivo que dise√±amos para simplificar la pr√°ctica y afirmar los conocimientos vistos en las clases de **PEPA** (**P**ensamiento **E**stad√≠stico en **P**eople **A**nalytics) y pensado para simplificar lo m√°s posible los ejercicios sin que requiera tanto de vos escribiendo c√≥digo.

Los scripts que usaremos en este documento los pod√©s copiar y pegar para reutilizarlos en tu propia PC. Record√° que ten√©s estos recursos a disposici√≥n:

-   [Mapa conceptual](https://miro.com/app/board/o9J_l_mwKFM=/) de R y RStudio con sus respectivos videos explicativos.
-   [Tutorial interactivo de Introducci√≥n a R](https://chechoid.shinyapps.io/clase_1_introduccion_r_y_tidyverse/)
-   Todo el material del [Club de R para RRHH](https://drive.google.com/drive/folders/1Qck3z_t6XLRXb2vbN-00931DgdJZ0yse?usp=sharing) en Google Drive. Cada carpeta de cada mes, tiene un link a su respectivo video en Youtube. Y ac√° hay contenido introductorio, hasta cosas m√°s complejas como an√°lisis predictivos, text mining o an√°lisis de clusters por ejemplo.

## ¬øC√≥mo usar este tutorial?

Este tutorial va a tener distintas secciones, en las cuales vas a poder correr los resultados directamente aprentando el √≠cono que dice **"Run Code"**.

Por ejemplo, prob√° sumar 2 + 2 y hacer click en **"Run Code"**.

```{r two-plus-two, exercise=TRUE}

```

El c√≥digo tambi√©n corre con las teclas *Ctrl+Enter.*

En cada ejercicio vas a poder encontrar pistas en la tecla **"Hint"**. Calcul√° tu edad en el siguiente script:

```{r edad, exercise=TRUE, exercise.lines = 9}
# Pon√© el a√±o en el que naciste
anio_nacimiento <- ____
anio_actual <- 2021

# Calcul√° tu edad
edad <- _______ - ________

# Visualiz√° los resultados
edad
```

```{r edad-hint-1}
# Reemplaz√° las l√≠neas ____ por el a√±o en el que naciste
# Para calcular tu edad rest√° el a√±o actual menos tu a√±o de nacimiento
```

```{r edad-hint-2}
# Pon√© el a√±o en el que naciste
anio_nacimiento <- 1979
anio_actual <- 2021

# Calcul√° tu edad
edad <- anio_actual - anio_nacimiento

# Visualiz√° los resultados
edad
```


## Explorando los datos

Para este tutorial vamos a utilizar el dataset de la **Encuesta KIWI de Sueldos LATAM** ü•ù que est√°n almacenados en un objeto .`RDS` que es una extensi√≥n propia de R para almacenar datos y que mantiene las caracter√≠sticas de los datos. Tambi√©n hay una versi√≥n `.csv` en el [repositorio de esta clase](https://github.com/chechoid/dpa-itba/tree/main/PEPA). La versi√≥n completa del Dataset se puede descargar de [Kaggle](https://www.kaggle.com/sergiogarciamora/encuesta-de-sueldos-de-rrhh-latam).

```{r carga-datos, echo=TRUE, eval=FALSE}
# Cargamos los datos
kiwi_ar <- readRDS("kiwi_ar.RDS")
```


```{r carga-datos2}
# library(readr)
# library(dplyr)
# 
# kiwi_ar <- read_delim("kiwi_ar.csv", delim = ";")
# 
# # Ordena los puestos por jerarqu√≠a
# kiwi_ar <- kiwi_ar %>% 
#   mutate(puesto = factor(puesto, levels = c("Administrativo", "Analista", "HRBP",
#                                             "Responsable", "Jefe", "Gerente")))
# 
# kiwi_ar <- kiwi_ar %>% 
#   mutate(rangos_aumentos = case_when(
#     ajuste_porcentaje == 0  ~ "Sin aumentos",
#     ajuste_porcentaje <= 10 ~ "Entre 1 y 10",
#     ajuste_porcentaje <= 20 ~ "Entre 11 y 20",
#     ajuste_porcentaje > 30  ~ "Entre 21 y 30",
#     ajuste_porcentaje = TRUE ~ "M√°s de 30"
#   ),
#   rangos_aumentos = factor(rangos_aumentos, levels = c("Sin aumentos", "Entre 1 y 10", "Entre 11 y 20", "Entre 21 y 30", "M√°s de 30")))

```

Corr√© la siguiente l√≠nea de c√≥digo y respond√© la pregunta a continuaci√≥n

```{r str, exercise=TRUE}
# Ver la estructura del data frame
str(kiwi_ar)
```

```{r str-q, }
quiz(
  question("¬øCu√°ntas filas y columnas tiene el dataframe 'salarios'?",
  answer("548 columnas y 44 variables", message = "Las observaciones son las filas y las variables son las columnas. Columna es sin√≥nimo de variable en este contexto."),
  answer("548 variables y 44 filas", message = "Mir√° de nuevo la primera fila del resultado de la estructura del dataframe kiwi_ar. Primero indica las observaciones, y luego las variables"),
  answer("548 filas y 44 columnas", correct = TRUE, message = "Muy bien!"),
  submit_button = "Enviar respuesta",
  try_again_button = "Intenta de nuevo",
  allow_retry = TRUE
))
```

## An√°lisis Univariado

Con el **an√°lisis univariado** lo que hacemos es analizar una variable a la vez. Dependiendo si la variable es *categ√≥rica* o *num√©rica* vamos a poder realizar distintas c√°lculos y an√°lisis.

```{r librerias}
library(tidyverse)
library(funModeling)
library(summarytools)
library(scales)
```

## Trabajando con variables categ√≥ricas

Con las variables *categ√≥ricas,* ya sean *nominales* u *ordinales*, no podemos hacer calculos aritm√©ticos como sumas, promedios y cosas por el estilo. ¬øQu√© podemos hacer? Por ejemplo contar casos.

```{r cate-1, exercise=TRUE}
library(tidyverse) # Limpieza y manipulaci√≥n de datos

kiwi_ar %>% 
  count(puesto) # Cuenta la cantidad de casos por puesto
```

Contar casos de una variable, como en el ejemplo anterior que contamos la cantidad de respuestas recibidas para cada puesto, en estad√≠stica se llama **Distribuci√≥n de Frecuencias**. ¬øPor qu√©?

![](https://cdn.memegenerator.es/imagenes/memes/full/29/80/29808033.jpg){width="300"}

En realidad, debe haber un por qu√©, pero podremos sobrevivir sin saberlo.

En ocasiones, algo que permite hacer m√°s claras las interpretaciones de los resultados es agregar los porcentajes.

```{r cate-2, exercise=TRUE}
# Tidyverse ya est√° cargado
library(scales) # Es para usar la funci√≥n percent() a continuaci√≥n  

# Hace click en "Run Code"
kiwi_ar %>% 
  count(puesto) %>% 
  mutate(porcentaje = percent(n / sum(n))) # Toma el valor de la celda en n y lo divide por el total de la columna n
```

Al incorporar el porcentaje en el an√°lisis lo que estamos haciendo es agregar, lo que en estad√≠stica se llama **Frecuencias Relativas.**

En el data frame tenemos entonces tres posiciones, `Administrativo`, `Analista`, y `HRBP` que no son posiciones jer√°rquicas. ¬øQu√© porcentaje del total representan?

Dados que los datos est√°n ordenados por jerarqu√≠a (¬øc√≥mo se llaman estas variables?) podemos sumar el porcentaje de `Administrativo` al porcentaje de `Analista`, y ese total, sumarlo a `HRBP`. Usemos la funci√≥n `freq()` del paquete `summarytools` para hacerlo f√°cilmente.

```{r cate-3, exercise = TRUE}

kiwi_ar %>% 
  select(puesto) %>% 
  freq(report.nas = FALSE)
```

Si vamos sumando los porcentajes de cada fila, *acumul√°ndolos* (agregando primero `Administrativo` y `Analista` y siguiendo despu√©s con `HRBP` y as√≠ sucesivamente) lo que estamos haciendo es una **Distribuci√≥n de Frecuencias Relativas Acumuladas**.

Entonces, ¬øqu√© porcentaje de las respuestas pertenecen a personas en puestos no jer√°rquicos?

```{r cate-4}
quiz(
  question("¬øQu√© porcentaje de las respuestas son de personas en posiciones no jer√°rquicas (considerando Administrativos, Analistas y HRBP)?",
           answer("10.40%", message = "Ese es el porcentaje de los HRBP"),
           answer("56.39%", message = "Excelente!", correct = T),
           answer("45.99%", message = "Esa es el porcentaje acumulado de Administrativo y Analista. Falta sumar el porcentaje de los HRBP."),
           submit_button = "Enviar respuesta",
           try_again_button = "Intenta de nuevo",
           allow_retry = TRUE
))
```

## Repaso

-   **Distribuci√≥n de frecuencias:** Que es el conteo, en este caso, de la cantidad de respuestas recibidas por puesto.

-   **Frecuencias relativas:** Que es el *porcentaje* que representa el conteo sobre el total.

-   **Frecuencia relativas acumuladas:** Que representa el *porcentaje acumulado* de los ingresos de cada trimestre.

## Pr√°ctica 1

¬øSe puede tomar mate en todas las empresas? Veamos la cantidad de respuestas de la variable `mate` para ver en cu√°ntos casos respondieron que s√≠ se pod√≠a tomar, y cu√°ntos respondieron que no. Reemplaz√° los espacios vac√≠os seg√∫n corresponda al nombre de la funci√≥n o de la variable.

```{r cate-5, exercise=TRUE}
kiwi_ar %>% 
  count(_____)
```

```{r cate-5-hint-1}
# Reemplaz√° el espacio vac√≠o dentro de la funci√≥n count() con el nombre de la variable 'mate'
```

```{r cate-5-hint-2}
kiwi_ar %>% 
  count(mate)
```

![](https://i.pinimg.com/736x/37/55/13/3755137bec08eab75fa7351696803b53.jpg){width="287"}

¬øY qu√© porcentaje representan de las respuestas? Agrega una columna calculando el porcentaje (frecuencia relativa).

```{r cate-6, exercise=TRUE, exercise.lines = 5}
kiwi_ar %>% 
  ______(____) %>% # Complet√° con la funci√≥n y la variable que corresponde
  mutate(porcentaje = round(n/sum(n),2)) # Agrega una columna con los porcentajes redondeando a 2 decimales.
```

```{r cate-6-hint-1}
# Us√° la funci√≥n count() para contar la cantidad de respuestas por cada caso
# La variable que queremos analizar se llama 'mate'
```

```{r cate-6-hint-2}
kiwi_ar %>% 
  count(mate) %>% # Complet√° con la funci√≥n y la variable que corresponde
  mutate(porcentaje = round(n/sum(n),2)) # Agrega una columna con los porcentajes redondeando a 2 decimales.
```

Calcular la distribuci√≥n de frecuencias acumuladas seg√∫n la `region`. Reemplaz√° los espacios vac√≠os seg√∫n corresponda al nombre de la funci√≥n o de la variable.

```{r cate-7, exercise=TRUE, exercise.lines = 4}
kiwi_ar %>% 
  select(______) %>% 
  freq(report.nas = FALSE)
```

```{r cate-7-hint-1}
# Reemplaz√° el espacio vac√≠o dentro de la funci√≥n select() con el nombre de la variable 'region'
```

```{r cate-7-hint-2}
kiwi_ar %>% 
  select(region) %>% 
  freq(report.nas = FALSE)
```

## An√°lisis Univariado Variables Categ√≥ricas - Visualizaci√≥n

Para visualizar una sola variable categ√≥rica, las opciones principales son los gr√°ficos de **barras** y los gr√°ficos de **torta** o de **dona**, con sus respectivas ventajas y desventajas.

## Gr√°ficos de barras

Para hacer un gr√°fico de barras podemos utilizar una funci√≥n la funci√≥n de R base `plot()` indicando la variable que queremos visualizar (indicando primero el nombre del data frame despu√©s del signo `$` el nombre de la variable).

```{r catev-1, exercise=TRUE}
# Realizar un gr√°fico de barra
plot(kiwi_ar$puesto)
```

Si usamos la misma funci√≥n con una variable num√©rica vamos a obtener un gr√°fico diferente.

```{r catev-2, exercise=TRUE}
# Realizar un gr√°fico de cantidad de personas a cargo
plot(kiwi_ar$sueldo_bruto)
```

En este caso lo que hace R es asignarle un n√∫mero de √≠ndice (el n√∫mero de la fila) y es lo que grafica en el eje `x` mientras que en el eje `y` asigna el valor de `sueldo_bruto`.

Volvamos a los gr√°ficos de barras.

Uno de los paquetes m√°s utilizados para hacer visualizaciones es el paquete `ggplot2` que ya viene incorporado dentro de la suite `tidyverse`, o sea que no hace falta instalarlo aparte si ya instalamos previamente `tidyverse`. Hay muchos paquetes m√°s para hacer visualizaciones, la ventaja de `ggplot2` es que hay muchos desarrollos y extensiones dise√±adas para funcionar con sus funciones, lo cual lo hace un gran punto de partida.

Primero tenemos que "activar" el paquete con la funci√≥n `library()`.

```{r catev-3, exercise=TRUE}
# Cargar el paquete con la funci√≥n library()
_______(ggplot2)

# Realizar el gr√°fico de barras
ggplot(kiwi_ar,             # Primero indicamos el nombre del dataframe
       aes(x = puesto)) +   # Dentro de aes() mapeamos la variable que queremos graficar
  geom_bar()                # Indico el tipo de gr√°fico
```

```{r catev-3-hint}
# Cargar el paquete con la funci√≥n library()
library(ggplot2)

# Realizar el gr√°fico de barras
ggplot(kiwi_ar,             # Primero indicamos el nombre del dataframe
       aes(x = puesto)) +   # Dentro de aes() mapeamos la variable que queremos graficar
  geom_bar()                # Indico el tipo de gr√°fico
```

`geom_bar()` requiere que le indiquemos una sola variable. Lo que hace es contar la cantidad de veces (la frecuencia) con la que aparece cada caso, y en funci√≥n de la cantidad de veces que aparece cada puesto en el dataset, va aumentando el tama√±o de la barra. Para m√°s informaci√≥n sobre los distintos *geoms* consultar la [documentaci√≥n](https://ggplot2.tidyverse.org/) del sitio de `ggplot2` o bien la [gu√≠a que confeccionamos](https://docs.google.com/document/d/1JAthc42Hno3tIhvZRrjA02zRCdS8q2uixODCBaZcPJ0/edit?usp=sharing).

```{r catev-4}
quiz(
  question("¬øQu√© pasa si asignamos la variable puesto al eje y?",
           answer("Nada", message = "No pasa nada grave pero algo pasa, prob√° reemplazando x por y en el bloque de c√≥digo anterior"),
           answer("Le agarra un virus a la compu y aparezco en la lista de los m√°s buscados por la Interpol", message = "Les dije 1 mill√≥n de veces que no sean exagerados"),
           answer("El gr√°fico 'se da vuelta'", correct = TRUE, message = "Correcto! Los nombres de los puestos aparecen en el eje y (m√°s legibles de hecho) y las barras est√°n apaisadas"),
         submit_button = "Enviar respuesta",
         try_again_button = "Intenta de nuevo",
         allow_retry = TRUE  
  )
)
```

## Gr√°ficos de torta o de dona

Para bien o para mal, los gr√°ficos de torta no tienen un *geom* espec√≠fico, y si bien en R base hay una funci√≥n espec√≠fica para hacerlos, requiere un poco de preprocesamiento previo.

En esencia los pasos para hacer un buen gr√°fico de torta son los siguientes:

1.  Preparar los datos para que las categor√≠as queden ordenadas de mayor a menor seg√∫n su frecuencia.

2.  Hacer un gr√°fico apilado al 100%

3.  "Doblar" el gr√°fico hasta que quede como un gr√°fico de torta o dona.

Este ser√≠a un gr√°fico apilado al 100%

```{r categ-5}
# Preparaci√≥n de los datos
puestos <- kiwi_ar %>% 
  select(puesto) %>%    # Seleccionamos la columna tipo universidad
  group_by(puesto) %>%  # Agrupamos los resultados
  summarise (n = n()) %>%         # Contamos la cantidad de casos para cada grupo
  mutate(freq = n/sum(n)) %>%     # Creamos una columna nueva calculando la frecuencia relativa
  arrange(-n)                     # Ordenamos los resultados de mayor a menor

# Calcular los porcentajes acumulados (tope de cada rect√°ngulo)
puestos$ymax <- cumsum(puestos$freq)

# Calcula el l√≠mite inferior
puestos$ymin <- c(0, head(puestos$ymax, n=-1))

ggplot(puestos, aes(ymax=ymax, ymin=ymin, xmax=4, xmin=3, fill=puesto)) +
  geom_rect()
```

Y ahora lo tenemos que "doblar".

![](https://miro.medium.com/max/900/1*6JHx7caXdrL1SQ9mI3KRuA.jpeg){width="291"})

Los pasos para hacer un gr√°fico de dona son los siguientes. Pod√©s copiar el script en tu m√°quina para probar el paso a paso.

```{r pie-chart, echo=TRUE}
# Preparaci√≥n de los datos
puestos <- kiwi_ar %>% 
  select(puesto) %>%    # Seleccionamos la columna tipo universidad
  group_by(puesto) %>%  # Agrupamos los resultados
  summarise (n = n()) %>%         # Contamos la cantidad de casos para cada grupo
  mutate(freq = n/sum(n)) %>%     # Creamos una columna nueva calculando la frecuencia relativa
  arrange(-n)                     # Ordenamos los resultados de mayor a menor

# Calcular los porcentajes acumulados (tope de cada rect√°ngulo)
puestos$ymax <- cumsum(puestos$freq)

# Calcula el l√≠mite inferior
puestos$ymin <- c(0, head(puestos$ymax, n=-1))

# Hacemos el gr√°fico
ggplot(puestos, aes(ymax=ymax, ymin=ymin, xmax=4, xmin=3, fill=puesto)) +
  geom_rect() +
  coord_polar(theta="y") + # Elimina esta l√≠nea de c√≥digo para entender lo que hace R.
  xlim(c(2, 4)) + # Prueben eliminando esta l√≠nea de c√≥digo para hacer un gr√°fico de torta
  theme_void() +                             # Cambia est√©tica del gr√°fico
  theme(legend.position = "top",            # Cambia la posici√≥n de la leyenda
        plot.title.position = "plot") +      # Cambia la posici√≥n del t√≠tulo  
  labs(title = "Respuestas por puesto",
       fill = "Puesto")

```

![](https://raw.githubusercontent.com/chechoid/dpa-itba/main/PEPA/pie_crocs.jpg){width="355"}

## Trabajando con variables cuantitativas

Con las variables num√©ricas, por otro lado podemos hacer an√°lisis mucho m√°s diversos que con las variables categ√≥ricas. Podemos hacer desde c√°lculos aritm√©ticos (sumas, restas, multiplicaciones y divisiones) hasta *c√°lculos de resumen estad√≠stico* (promedio, mediana, desv√≠o est√°ndar, etc.).

Dado que las variables cuantitativas pueden a veces tomar valores infinitos, hacer un c√°lculo de frecuencias por los valores que tenemos puede ser dif√≠cil de interpretar.

Veamos este ejemplo donde tomamos la variable `ajuste_porcentaje` que indica el valor porcentual de aumentos salariales recibidos durante 2020 (el relevamiento de datos se hizo en octubre).

```{r num-1, exercise = TRUE}
# An√°lisis cuantitativo no agrupado 
kiwi_ar %>% 
  count(ajuste_porcentaje)
```

Terminamos con una tabla con 68 filas que tiene niveles de detalles poco √∫tiles (una respuesta detallando que el ajuste fue de `12.69%`, dos personos recibieron `12.8%` de aumento por ejemplo). Esto es lo que ocurre cuando tenemos **datos cuantitativos no agrupados**.

En cambio, si armamos categor√≠as, con rangos de aumentos, podemos terminar con algo mucho m√°s informativo, y √∫til para analizar. A esto le llamaremos an√°lisis de **datos cuantitativos agrupados.**

```{r num-2, exercise=TRUE}
kiwi_ar %>% 
  select(rangos_aumentos) %>% 
  freq(report.nas = FALSE)
```

## An√°lisis Univariado Variables Cuantitativas - Visualizaci√≥n

Antes de meternos con las medidas de resumen estad√≠stico, y aprovechando este √∫ltimo concepto de datos cuantitativos agrupados, vamos a plantear algunas posibles visualizaciones.

Primero, realicemos un gr√°fico de barras sobre la variable `ajuste_porcentaje`.

```{r num-3, exercise=TRUE}
ggplot(kiwi_ar, aes(x = ajuste_porcentaje)) +
  geom_bar()
```

Hay tantos valores posibles que muchas barras pasan desapercibidas. Probemos graficar los rangos de aumentos.

```{r num-4, exercise=TRUE}
ggplot(kiwi_ar, aes(x = rangos_aumentos)) +
  geom_bar()
```

Esta forma de graficar una variable *cuantitativa* en categor√≠as nos sirve para introducir un tipo de gr√°fico muy utilizado en Analytics, que es el **histograma**.

A primera vista, el *histograma* parece un gr√°fico de barras, con la diferencia que la barra no representa un valor √∫nico (por ejemplo 5), sino un *rango de valores*. (por ejemplo, entre 5 y 10). Ergo, el alto de la barra va a estar dado por la cantidad de casos que caigan dentro de cada rango.

![Ay el arquitecto de Matrix diciendo ergo](https://alchetron.com/cdn/architect-the-matrix-7af001d6-8db4-40d6-8e40-fbf29656e28-resize-750.jpeg ""Ergo"")

De nuevo, hay varias formas de hacer un histograma en R. En R base la forma es la siguiente:

```{r hist-1, exercise = TRUE}
hist(kiwi_ar$ajuste_porcentaje)
```

Y en `ggplot2` la forma de hacerlo es la siguiente:

```{r hist-2, exercise=TRUE}
ggplot(kiwi_ar, aes(x = ajuste_porcentaje)) +
  geom_histogram(bins = 15) # Ajusta la cantidad de barras que van a aparecer en el gr√°fico
```

Prueben distintas versiones del histograma cambiando la cantidad de `bins` o incluso borrando todo lo que est√° dentro del par√©ntesis de `geom_histogram()`.

Podemos agregar una capa adicional de informaci√≥n a la visualizaci√≥n con un gr√°fico adicional conocido como **pol√≠gono de frecuencia.** Una clave para que este gr√°fico funcione bien en conjunto con el histograma es que ambos tengan el mismo valor en `bins`.

```{r freq-1, exercise = TRUE}
ggplot(kiwi_ar, aes(x = ajuste_porcentaje)) +
  geom_histogram(bins = 15) +
  geom_freqpoly(aes(ajuste_porcentaje),  # A√±adimos el pol√≠gono de frecuencia
                bins = 15)
```

Esta capa extra nos ayuda a identificar de manera m√°s clara la **distribuci√≥n** de los datos. ¬øPor qu√© es importante conocer la distribuci√≥n de los datos? Porque a veces los datos, los c√°lculos y las medidas de resumen pueden *esconder* algunos problemas.

![](https://raw.githubusercontent.com/chechoid/dpa-itba/main/PEPA/distribucion.png){width="593"}

Busquen informaci√≥n sobre el [Cuarteto de Anscombe](http://ptarra.blogspot.com/2013/05/el-cuarteto-de-anscombe.html) y especialmente del [Datasaurus Dozen](http://www.thefunctionalart.com/2016/08/download-datasaurus-never-trust-summary.html).

## Pr√°ctica 2

```{r carga-datos3}
library(funModeling)

percentiles = profiling_num(kiwi_ar$sueldo_bruto)

p05 = percentiles[1,6]
p95 = percentiles[1,10]

kiwi_limpio = kiwi_ar %>% 
  filter(between(sueldo_bruto, p05, p95))
```

Realizar un histograma de la variable `sueldo_bruto`.

```{r hist-4, exercise=TRUE}
ggplot(kiwi_ar, aes(x = _______)) +
  geom_histogram()
```

```{r hist-4-hint-1}
# Coloc√° el nombre de la variable a graficar (sueldo_bruto)
```

```{r hist-4-hint-2}
ggplot(kiwi_ar, aes(x = sueldo_bruto)) +
  geom_histogram()
```

Aqu√≠ nos encontramos con el problema de los *outliers*. ¬øCu√°l es el `sueldo_bruto` m√°s alto? ¬øY el m√°s bajo?

```{r hist-5, exercise = TRUE}
# Cu√°l imaginan que es la funci√≥n para calcular el valor m√°ximo de una columna
___(kiwi_ar$____)

# Detectar el sueldo bruto m√°s bajo
min(_____$sueldo_bruto)
```

```{r hist-5-hint}
# Cu√°l imaginan que es la funci√≥n para calcular el valor m√°ximo de una columna
max(kiwi_ar$sueldo_bruto)

# Detectar el sueldo bruto m√°s bajo
min(kiwi_ar$sueldo_bruto)
```

Vemos que tenemos un `sueldo_bruto` de m√°s de \$ 2 millones de pesos. En el histograma anterior, tambi√©n podemos identificar otro caso at√≠picamente alto, ¬øen qu√© rango salarial se encuentra?

```{r hist-6}
quiz(
  question(
    "¬øEn qu√© rango salarial encontramos otro outlier o valor at√≠pico?",
    answer("Entre $ 250.000 y $ 500.000", message = "Nop, prob√° otra vez"),
    answer("Entre $ 500.000 y $ 1.000.000", correct = TRUE, message = "Excelente! Hay una respuesta de $ 650.000"),
    answer("Entre $ 1.000.000 y $ 1.500.000", message = "Nop, prob√° otra vez"),
    allow_retry = TRUE, 
    submit_button = "Enviar respuesta",
    try_again_button = "Intenta de nuevo"
  )
)
```

Usando un data frame nuevo, llamado `kiwi_limpio` realizar nuevamente el histograma de la variable `sueldo_bruto`.

```{r hist-7, exercise=TRUE}
____(______$________)
```

```{r hist-7-hint-1}
# La funci√≥n de R base es hist
# Pon√© primero el nombre del nuevo data frame y luego la variable sueldo_bruto
```

```{r hist-7-hint-2}
# El nuevo data frame se llama kiwi_limpio
# Record√° poner nombre_dataframe$nombre_variable
```

```{r hist-7-hint-3}
hist(kiwi_limpio$sueldo_bruto
```

## Medidas de resumen estad√≠stico

La estad√≠stica es una disciplina que suele trabajar con *muestras*. Con cierta frecuencia, nos encontramos que no podemos analizar a todos los empleados porque ser√≠a muy costoso en tiempo y recursos, o bien porque nos interesa segmentar el an√°lisis sobre alguna muestra en particular.

Sobre esas muestras hacemos *inferencias* sobre la poblaci√≥n que estamos analizando.

En nuestro caso, la **poblaci√≥n** de la encuesta es de `r nrow(kiwi_ar)` casos. De ese total, podr√≠amos pensar en las siguientes **muestras** de datos por ejemplo:

-   Personas en posiciones de Gerente.

-   Conjunto de mujeres en posiciones de liderazgo.

-   Personas que recibieron m√°s de un aumento salarial.

-   etc..

```{r est-1, echo=TRUE}
# Personas en posiciones de Gerente
kiwi_ar %>% 
  filter(puesto == "Gerente") %>% 
  count(puesto)

# Conjunto de mujeres en posiciones de liderazgo
kiwi_ar %>% 
  filter(es_lider == 1, genero == "Femenino") %>% 
  count(puesto)

# Personas que recibieron m√°s de un aumento salarial
kiwi_ar %>% 
  filter(ajuste %in% c("2 ajustes", "3 o m√°s ajustes")) %>% 
  count(ajuste)
```

Todo esto es para hacer una introducci√≥n al **promedio**, denominado tambi√©n **media muestral**.

```{r carga-datos-4}
df_edad <- read.csv("edades.csv")
edades <- df_edad %>% select(Edad) %>% pull()
edades <- sort(edades)
```

## Promedio

El **promedio** o **media muestral** es una medida de tendencia central. Esto quiere decir que ese valor ser√° el m√°s representativo del conjunto de datos (o al menos eso se espera). Para hacer algunos ejemplos vamos a usar las edades de los alumnos de un curso.

```{r prom-1, exercise = TRUE}
edades
```

Como explica Walter Sosa Escudero, si todas estas personas entraran en un aula, y se fundieran en uno solo, la edad que tendr√≠a esa persona que representa a todos, ser√≠a la *edad promedio*.

La funci√≥n para calcular la media muestral o promedio se llama `mean()`.

```{r prom-2, exercise=TRUE}
____(edades)
```

```{r prom-2-hint}
mean(edades)
```

Como ya saben, el promedio es sensible a los valores extremos. Creen un nuevo vector llamado `edades_2` y modifiquen el primer valor del vector y pongan 120 y vuelvan a calcular el promedio.

```{r prom-3, exercise=TRUE}
# Crear un nuevo vector con los valores de edad
edades_2 <- edades

# Modificar el primer elemento y poner 120
edades_2[1] <- ____
edades_2

# Calcular nuevo promedio del vector edades_2
____(_________)
```

```{r prom-3-hint}
# Crear un nuevo vector con los valores de edad
edades_2 <- edades

# Modificar el primer elemento y poner 120
edades_2[1] <- 120
edades_2

# Calcular nuevo promedio del vector edades_2
mean(edades_2)
```

```{r promedio-2}
# Crear un nuevo vector con los valores de edad
edades_2 <- edades

# Modificar el primer elemento y poner 120
edades_2[1] <- 120
```

Podemos apreciar que el promedio pas√≥ de `r round(mean(edades),2)` en el primer vector, y con el segundo vector cambi√≥ a `r round(mean(edades_2),2)` .

Algo muuuuy importante en estad√≠stica es el concepto de *distancia*. Una caracter√≠stica del promedio es que es el valor que tiene la menor distancia a todos los puntos. Se los dejo picando porque este concepto va a ser √∫til para entender algo m√°s adelante cuando hablemos de regresiones lineales.

Prueben calculando las diferencias entre los datos contra el promedio, y con otros n√∫meros al azar.

```{r mean-3, exercise = TRUE}
# Guardar el promedio edades
promedio_edad <- mean(edades)

# Grafiquemos las edades para cada persona
ggplot(df_edad, aes(x = Edad, y = Inicial)) +
  geom_point(size = 3) +
  geom_vline(xintercept = promedio_edad, size = 1, color = "red")
```

## Mediana y cuantiles

As√≠ como el promedio es una medida de *tendencia central*, al igual que la **mediana**. Los **cuantiles** son medidas **de orden** (por ende los \*cuartiles o deciles\* tambi√©n lo son). Lo que hacen estas medidas es ordenar los datos de mayor a menor, y nos indican cu√°l es el valor que est√° en:

Internamente, para calcular la mediana, se ordenan los valores de mayor a menor y se busca el valor que est√° en la mitad de la variable.

![](https://karatedolam.files.wordpress.com/2011/07/karate_tameshiwari.jpg){width="196"}

Si tenemos una cantidad de datos impares, el valor que est√° justo a la mitad (dejando la misma cantidad de casos de un lado y del otro) esa ser√° la mediana.

Si tenemos una cantidad par de datos, para calcular la mediana, hacemos un promedio entre los valores que est√°n en la mitad de los valores.

Nuestro vector `edades` tiene 11 elementos. ¬øCu√°l ser√° la mediana?

```{r med-1, exercise = TRUE}
# Correr el script y pensar cu√°l ser√° la mediana
edades

# Verificar calculando la mediana con la funci√≥n median
median(______)
```

```{r med-1-hint}
# Correr el script y pensar cu√°l ser√° la mediana
edades

# Verificar calculando la mediana con la funci√≥n median
median(edades)
```

Creemos un nuevo vector llamado `edades_3` agregando un nuevo elemento y calcular la mediana usando la funci√≥n `median()`.

```{r med-2, exercise = TRUE}
#Crear un nuevo vector
edades_3 <- edades

# Agregar un nuevo valor
edades_3[12] <- 50

# Calcular la mediana
_____(edades_3)
```

```{r med-2-hint}
#Crear un nuevo vector
edades_3 <- edades

# Agregar un nuevo valor
edades_3[12] <- 50

# Calcular la mediana
median(edades_3)
```

Es bien sabido que una propiedad de la mediana es que no se ve afectada por los valores extremos.

```{r med-3, exercise = TRUE}
#Crear un nuevo vector
edades_4 <- edades

# Modificar el primer valor con un valor alto
edades_4[1] <- 150

# Calcular la mediana
median(edades_4)

```

Hay cuantiles que tienen *"nombres propios"**.*** Por ejemplo,

Los **cuartiles** que dividen a la variable en 4 partes (en el 25%, 50% y 75% de los datos.

Los **quintiles** que dividen a la variable en 5 partes. (en el 20%, 40%, 60%, 80% de los datos).

Los **deciles** que dividen a la variable en 10 partes. (en el 10%, 20%, 30%, 40%, 50%, 60%, 70%, 80%, 90% de los datos).

En la pr√°ctica se suelen usar con mucha frecuencia los **cuartiles**, y para algunas medidas de control de los modelos predictivos se controlan resultados usando los **deciles.**

Usemos el data frame `kiwi_ar`. Una forma de r√°pidamente los *cuartiles* es usando la funci√≥n `summary()`. Hagamos el c√°lculo sobre la variable `edad`.

```{r q1, exercise=TRUE}
summary(kiwi_ar$edad)
```

La funci√≥n `summary()` nos permite ver r√°pidamente:

-   Los valores **m√≠nimo** y **m√°ximo**.

-   El **primer** y **tercer cuartil**.

-   La **mediana** (median).

-   El **promedio** (mean).

Si queremos definir los *quintiles* o los *deciles*, tenemos que hacerlo manualmente con la funci√≥n `quantile()`.

```{r q2, exercise = TRUE}
# Calcular los deciles
quantile(kiwi_ar$edad, c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8))

```

Volviendo a los **cuartiles**, entre el *primer cuartil* y el *tercer cuartil* se encuentran la mitad de los datos ü§Ø. En alg√∫n momento de la historia, alg√∫n estad√≠stico o estad√≠stica muy fum√≥n o fumona se le ocurri√≥ restar al valor del 3er cuartil el valor del 1er cuartil y a eso lo llam√≥ **Rango Intercuartil** (se lo conoce con las siglas IQR en ingl√©s).

Hagamos la prueba con la variable `edad` del data frame `kiwi_ar`.

```{r q3, exercise = TRUE}
# Calcular el primer cuartil
q1 <- quantile(kiwi_ar$edad, 0.25)

# Calcular el tercer cuartil
q3 <- ________(______$___ , ___)

# Calcular el rango intercuartil
rango_ic <- ___ - ___

rango_ic
```

Ya s√©, se est√°n preguntando *"¬øPara qu√© carajo me sirve todo esto?"*. El **rango intercuartil** es un paso necesario para determinar si un valor **es un outlier o no** ü§Øü§Øü§Ø**.**

Si a ese *rango intercuartil* lo multiplico por 1.5, y a eso se lo restamos al *primer cuartil* obtenemos el l√≠mite inferior para determinar los outliers, y si ese resultado (IQR x 1.5) se lo sumamos al *tercer cuartil* obtenemos el l√≠mite superior para detectar los outliers.

```{r q4, exercise=TRUE}
# Calcular el primer cuartil
q1 <- quantile(kiwi_ar$edad, 0.25)

# Calcular el tercer cuartil
q3 <- quantile(kiwi_ar$edad, 0.75)

# Calcular el rango intercuartil
rango_ic <- q3 - q1

# Calcular l√≠mite inferior
lim_inf <- q1 - rango_ic * 1.5

# Calcular l√≠mite superior
lim_sup <- _______________ * 1.5

# Ver ambos resultados
lim_inf
lim_sup
```

```{r q4-hint}
# Calcular el primer cuartil
q1 <- quantile(kiwi_ar$edad, 0.25)

# Calcular el tercer cuartil
q3 <- quantile(kiwi_ar$edad, 0.75)

# Calcular el rango intercuartil
rango_ic <- q3 - q1

# Calcular l√≠mite inferior
lim_inf <- q1 - rango_ic * 1.5

# Calcular l√≠mite superior
lim_sup <- q3 - rango_ic * 1.5

# Ver ambos resultados
lim_inf
lim_sup
```

Todo esto fue una excusa para introducir uno de mis gr√°ficos favoritos: los **boxplots**.

![](https://raw.githubusercontent.com/chechoid/dpa-itba/main/PEPA/boxplot.png){width="513"}

Hagamos un ejemplo con la variable `edad` del data frame `kiwi_ar`.

```{r q5, exercise = TRUE}
ggplot(kiwi_ar, aes(x = edad)) +
  geom_boxplot()
```

En el gr√°fico podemos apreciar que hay 3 *outliers* por encima de los 54 a√±os aproximadamente.

Algo interesante de los boxplots, es que tambi√©n nos da una idea de la distribuci√≥n de los datos.

```{r q6, out.width="70%"}
ggplot(kiwi_ar, aes(x = edad)) +
  geom_histogram()

ggplot(kiwi_ar, aes(x = edad)) +
  geom_boxplot()

```

El paquete `funModeling` tiene algunas funciones muy interesantes. Prueben la funci√≥n `profiling_num()` sobre la variable `edad`.

```{r q7, exercise = TRUE}
# install.packages("funModeling") # Por si es necesario

# Cargar librer√≠a
library(funModeling)

# Probar la funci√≥n profiling_num()
profiling_num(kiwi_ar$edad)
```

## Medidas de dispersi√≥n

Las medidas de dispersi√≥n son muy √∫tiles para saber qu√© tan lejos est√°n los datos del promedio por ejemplo, y concordantemente, *qu√© tan representativo es ese promedio y si est√° siendo influenciado o no por valores extremos*.

![Ay el arquitecto de Matrix diciendo "concordantemente"](https://alchetron.com/cdn/architect-the-matrix-7af001d6-8db4-40d6-8e40-fbf29656e28-resize-750.jpeg)

Dos m√©tricas que nos sirven para calcular la dispersi√≥n de los datos son la **varianza** y el **desv√≠o est√°ndar**. El *desv√≠o est√°ndar* es de hecho, la ra√≠z cuadrada de la varianza, y tiene la particularidad que tiene la misma unidad de medida que la variable. O sea qu√©:

-   Si calculo el desv√≠o est√°ndar de una variable en pesos argentinos, el desv√≠o estar√° expresado en pesos.

-   Si calculo el desv√≠o est√°ndar de una variable en cent√≠metros, el desv√≠o est√°ndar estar√° expresado en cent√≠metros.

-   Si calculo el desv√≠o est√°ndar de una variable en a√±os, el desv√≠o est√°ndar estar√° expresado en a√±os.

![](https://cdn.memegenerator.es/imagenes/memes/full/32/38/32381633.jpg)

Calculemos la varianza y el desv√≠o est√°ndar de la variable `edad` en el data frame `kiwi_ar`.

```{r dis-1, exercise=TRUE}
# Calcular la varianza
___(kiwi_ar$edad)

# Calcular el desv√≠o est√°ndar
__(kiwi_ar$edad)
```

```{r dis-1-hint-1}
# Busquen en google. Aprender a buscar soluciones en google tambi√©n es parte del aprendizaje para programar
```

```{r dis-1-hint-2}
# Calcular la varianza
___(kiwi_ar$edad)

# Calcular el desv√≠o est√°ndar
__(kiwi_ar$edad)
```

Otra medida que se puede calcular es el **coeficiente de variaci√≥n**, que es una medida de la variabilidad de una variable seg√∫n el tama√±o de la muestra (ver en [Wikipedia](https://es.wikipedia.org/wiki/Coeficiente_de_variaci%C3%B3n)).

Su c√°lculo es muy simple. Surge de dividir el *desv√≠o est√°ndar por el promedio*.

```{r dis-2, exercise=TRUE}
# Calcular el desv√≠o est√°ndar de la variable edad
desvio <- sd(kiwi_ar$edad)

# Calcular el promedio de la variable edad
promedio <- mean(kiwi_ar$edad)

# Calcular el coeficiente de variaci√≥n
coef_var <- desvio / promedio

coef_var
```

## Estandarizar o normalizar variables

¬øComo hacemos para analizar una relaci√≥n entre un sueldo que est√° expresado en miles de pesos y la experiencia que est√° expresada en a√±os? O llev√°ndolo a otro dominio, analizar la relaci√≥n entre el peso y la altura que tienen unidades de medida diferentes (kilos y cent√≠metros).

Para eso existe la **estandarizaci√≥n de variables**, tambi√©n conocida como **normalizaci√≥n de variables**, y en ocasiones tambi√©n **z-score**. Esto lo vamos a ver m√°s en profundidad cuando hagamos an√°lisis de dos muestras, pero como su c√°lculo involucra al *promedio* y al *desv√≠o est√°ndar* nos pareci√≥ interesante hacer un anticipo del tema, para luego m√°s adelante hablar de correlaciones por ejemplo.

La f√≥rmula para normalizar una variable es la siguiente:

![](https://wikimedia.org/api/rest_v1/media/math/render/svg/1eda92e3a28b3a7d693348c1b9dd871e5baec300)

Donde:

-   $x$ es el valor de cada observaci√≥n

-   $\bar{a}$ es la media muestral

-   $s$ es el desv√≠o est√°ndar de la muesta.

O sea que para valor de la variable R le va a restar a cada caso el promedio, y luego dividir al valor por el desv√≠o est√°ndar.

Veamos nuevamente el vector `edades`.

```{r z1, exercise=TRUE}
# Correr el script
edades

# Hacer un summary de edades
summary(edades)
```

Ahora veamos los valores *estandarizados*.

```{r z2, exercise=TRUE}
# Correr el script
scale(edades, center= TRUE, scale=TRUE)
```

```{r z3, exercise=TRUE}
# Guardar los valores estandarizados en un objeto
z_edad <- scale(edades, center= TRUE, scale=TRUE)

# Hacer un summary de este nuevo objeto
summary(z_edad)
```

M√°s adelante retomamos el tema, por ahora lo dejamos ac√°.

## Pr√°ctica 3

Calcular el promedio, la mediana y el desv√≠o est√°ndar de la variable `sueldo_bruto` del data frame `kiwi_ar`.

```{r desc-1, exercise=TRUE, exercise.lines=10}
# Calcular el promedio
___(kiwi_ar$sueldo_bruto)

# Calcular la mediana
____(______$_______)

# Calcular el desv√≠o est√°ndar
sd(____$_____)
```

```{r des-1-hint-1}
# La funci√≥n para calcular el promedio es mean

# La funci√≥n para calcular la mediana se llama median. Poner primero el nombre del data frame y luego el de la columna.

# Poner el nombre del data frame kiwi_ar y luego el de la columna sueldo_bruto
```

```{r des-2-hint-2}
# Calcular el promedio
mean(kiwi_ar$sueldo_bruto)

# Calcular la mediana
median(kiwi_ar$sueldo_bruto)

# Calcular el desv√≠o est√°ndar
sd(kiwi_ar$sueldo_bruto)
```

Otra alternativa para calcular estos resultados es usando la secuencias de `tidyverse`.

```{r des-3, exercise=TRUE}
kiwi_ar %>% 
  select(sueldo_bruto) %>% 
  summarise(promedio = mean(sueldo_bruto),
            mediana = median(sueldo_bruto),
            desvio = sd(sueldo_bruto))
```

Realizar un histograma de la variable `sueldo_bruto`. ¬øPor qu√© sale as√≠?

```{r des-4, exercise = TRUE}
# Realizar un histograma de sueldo_bruto
ggplot(_____, aes(x  = sueldo_bruto)) +
  geom_______(bins = 20)
```

```{r des-4-hint-1}
# Poner el nombre del data frame kiwi_ar

# Para hacer un histograma necesitamos usar geom_histogram()
```

```{r des-4-hint-2}
# Realizar un histograma de sueldo_bruto
ggplot(kiwi_ar, aes(x  = sueldo_bruto)) +
  geom_histogram(bins = 20)
```

Ahora crear un data frame nuevo, llamado `kiwi_limpio` filtrando todo lo que est√© por debajo del *percentil 5* y todo lo que est√© por encima del *percentil 95*.

```{r des-5, exercise = TRUE, exercise.lines = 22}
# Calcular el valor para el percentil 5
p5 <- quantile(kiwi_ar$sueldo_bruto, 0.05)
p5

# Calcular el valor para el percentil 95
p95 <- _______(_______$__________, 0.95)
p95

# Filtrar los sueldos por debajo y por encima de los percentiles 5 y 95 guard√°ndolos en un nuevo data frame
kiwi_limpio <- kiwi_ar %>% 
  filter(between(            # Filtra los casos que est√©n dentro de los l√≠mites
    sueldo_bruto,            # Columna para filtrar
    p5,                      # L√≠mite inferior
    p95                      # L√≠mite superior
  ))

# Realizar un histograma de sueldo_bruto
ggplot(kiwi_limpio, aes(x  = __________)) +
  geom_histogram(bins = 20)
```

```{r des-5-hint-1}
# Utilizar la f√≥rmula quantile y luego indicar el nombre del data frame y de la columna

# Asignar al eje x la variable sueldo_bruto
```

```{r des-5-hint-2}
# Calcular el valor para el percentil 5
p5 <- quantile(kiwi_ar$sueldo_bruto, 0.05)
p5

# Calcular el valor para el percentil 95
p95 <- quantile(kiwi_ar$sueldo_bruto, 0.95)
p95

# Filtrar los sueldos por debajo y por encima de los percentiles 5 y 95 guard√°ndolos en un nuevo data frame
kiwi_limpio <- kiwi_ar %>% 
  filter(between(            # Filtra los casos que est√©n dentro de los l√≠mites
    sueldo_bruto,            # Columna para filtrar
    p5,                      # L√≠mite inferior
    p95                      # L√≠mite superior
  ))

# Realizar un histograma de sueldo_bruto
ggplot(kiwi_limpio, aes(x  = sueldo_bruto)) +
  geom_histogram(bins = 20)
```

Los data frames `kiwi_ar` y `kiwi_limpio` est√°n almacenados en memoria. Realizar un boxplot de la columna `sueldo_bruto` para ambos datasets. ¬øQu√© interpretaci√≥n hacen de los resultados?

```{r des-6, exercise = TRUE}
# Realizar un boxplot para el data frame kiwi_ar
ggplot(_____, aes(x = sueldo_bruto)) +
  geom_______()

# Realizar un boxplot para el data frame kiwi_limpio
ggplot(kiwi_limpio, __________)) +
    geom_boxplot()
```

```{r des-6-hint-1}
# Reemplazar el primer espacio vac√≠o por el nombre del data frame
# Para hacer un boxplot necesit√°s usar geom_boxplot()

# Hay que asignar columna sueldo_bruto al eje x dentro de aes()
# Ten√© cuidado con los par√©ntisis al final de la primera l√≠nea del c√≥digo
```

```{r des-6-solution}
# Realizar un boxplot para el data frame kiwi_ar
ggplot(kiwi_ar, aes(x = sueldo_bruto)) +
  geom_boxplot()

# Realizar un boxplot para el data frame kiwi_limpio
ggplot(kiwi_limpio, aes(x = sueldo_bruto)) +
    geom_boxplot()
```

Por √∫ltimo, graficar un boxplot usando el data frame `kiwi_limpio` mapeando en el eje `x` el `puesto`, y en el eje `y` el `sueldo_bruto`. ¬øQu√© interpretaci√≥n hacen de los resultados?

```{r des-7, exercise=TRUE}
ggplot(kiwi_limpio, aes(x = puesto, y = sueldo_bruto)) +
    geom_boxplot()
```
