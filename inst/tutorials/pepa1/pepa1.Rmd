---
title: "Pensamiento Estad칤stico en People Analytics"
author: "Arturo De Zan | Sergio Garcia Mora"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
library(funModeling)
library(tidyverse)
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)

# Cargamos los datos
kiwi_ar <- readRDS("kiwi_ar.RDS")


percentiles = profiling_num(kiwi_ar$sueldo_bruto)

p05 = percentiles[1,6]
p95 = percentiles[1,10]

kiwi_limpio = kiwi_ar %>% 
  filter(between(sueldo_bruto, p05, p95))

df_edad <- read.csv("edades.csv")
edades <- df_edad %>% select(Edad) %>% pull()
edades <- sort(edades)

```

## Pensamiento Estad칤stico en People Analytics

![](https://youtu.be/Mz4GbMCqvcY){width="80%"}

Este es un tutorial interactivo que dise침amos para simplificar la pr치ctica y afirmar los conocimientos vistos en las clases de **PEPA** (**P**ensamiento **E**stad칤stico en **P**eople **A**nalytics) y pensado para simplificar lo m치s posible los ejercicios sin que requiera tanto de vos escribiendo c칩digo.

Los scripts que usaremos en este documento los pod칠s copiar y pegar para reutilizarlos en tu propia PC. Record치 que ten칠s estos recursos a disposici칩n:

-   [Mapa conceptual](https://miro.com/app/board/o9J_l_mwKFM=/) de R y RStudio con sus respectivos videos explicativos.
-   [Tutorial interactivo de Introducci칩n a R](https://chechoid.shinyapps.io/clase_1_introduccion_r_y_tidyverse/)
-   Todo el material del [Club de R para RRHH](https://drive.google.com/drive/folders/1Qck3z_t6XLRXb2vbN-00931DgdJZ0yse?usp=sharing) en Google Drive. Cada carpeta de cada mes, tiene un link a su respectivo video en Youtube. Y ac치 hay contenido introductorio, hasta cosas m치s complejas como an치lisis predictivos, text mining o an치lisis de clusters por ejemplo.

## 쮺칩mo usar este tutorial?

Este tutorial va a tener distintas secciones, en las cuales vas a poder correr los resultados directamente aprentando el 칤cono que dice **"Run Code"**.

Por ejemplo, prob치 sumar 2 + 2 y hacer click en **"Run Code"**.

```{r two-plus-two, exercise=TRUE}

```

El c칩digo tambi칠n corre con las teclas *Ctrl+Enter.*

En cada ejercicio vas a poder encontrar pistas en la tecla **"Hint"**. Calcul치 tu edad en el siguiente script:

```{r edad, exercise=TRUE, exercise.lines = 9}
# Pon칠 el a침o en el que naciste
anio_nacimiento <- ____
anio_actual <- 2021

# Calcul치 tu edad
edad <- _______ - ________

# Visualiz치 los resultados
edad
```

```{r edad-hint-1}
# Reemplaz치 las l칤neas ____ por el a침o en el que naciste
# Para calcular tu edad rest치 el a침o actual menos tu a침o de nacimiento
```

```{r edad-hint-2}
# Pon칠 el a침o en el que naciste
anio_nacimiento <- 1979
anio_actual <- 2021

# Calcul치 tu edad
edad <- anio_actual - anio_nacimiento

# Visualiz치 los resultados
edad
```


## Explorando los datos

Para este tutorial vamos a utilizar el dataset de la **Encuesta KIWI de Sueldos LATAM** 游볳 que est치n almacenados en un objeto .`RDS` que es una extensi칩n propia de R para almacenar datos y que mantiene las caracter칤sticas de los datos. Tambi칠n hay una versi칩n `.csv` en el [repositorio de esta clase](https://github.com/chechoid/dpa-itba/tree/main/PEPA). La versi칩n completa del Dataset se puede descargar de [Kaggle](https://www.kaggle.com/sergiogarciamora/encuesta-de-sueldos-de-rrhh-latam).

```{r carga-datos, echo=TRUE, eval=FALSE}
# Cargamos los datos
kiwi_ar <- readRDS("kiwi_ar.RDS")
```


```{r carga-datos2}
# library(readr)
# library(dplyr)
# 
# kiwi_ar <- read_delim("kiwi_ar.csv", delim = ";")
# 
# # Ordena los puestos por jerarqu칤a
# kiwi_ar <- kiwi_ar %>% 
#   mutate(puesto = factor(puesto, levels = c("Administrativo", "Analista", "HRBP",
#                                             "Responsable", "Jefe", "Gerente")))
# 
# kiwi_ar <- kiwi_ar %>% 
#   mutate(rangos_aumentos = case_when(
#     ajuste_porcentaje == 0  ~ "Sin aumentos",
#     ajuste_porcentaje <= 10 ~ "Entre 1 y 10",
#     ajuste_porcentaje <= 20 ~ "Entre 11 y 20",
#     ajuste_porcentaje > 30  ~ "Entre 21 y 30",
#     ajuste_porcentaje = TRUE ~ "M치s de 30"
#   ),
#   rangos_aumentos = factor(rangos_aumentos, levels = c("Sin aumentos", "Entre 1 y 10", "Entre 11 y 20", "Entre 21 y 30", "M치s de 30")))

```

Corr칠 la siguiente l칤nea de c칩digo y respond칠 la pregunta a continuaci칩n

```{r str, exercise=TRUE}
# Ver la estructura del data frame
str(kiwi_ar)
```

```{r str-q, }
quiz(
  question("쮺u치ntas filas y columnas tiene el dataframe 'salarios'?",
  answer("548 columnas y 44 variables", message = "Las observaciones son las filas y las variables son las columnas. Columna es sin칩nimo de variable en este contexto."),
  answer("548 variables y 44 filas", message = "Mir치 de nuevo la primera fila del resultado de la estructura del dataframe kiwi_ar. Primero indica las observaciones, y luego las variables"),
  answer("548 filas y 44 columnas", correct = TRUE, message = "Muy bien!"),
  submit_button = "Enviar respuesta",
  try_again_button = "Intenta de nuevo",
  allow_retry = TRUE
))
```

## An치lisis Univariado

Con el **an치lisis univariado** lo que hacemos es analizar una variable a la vez. Dependiendo si la variable es *categ칩rica* o *num칠rica* vamos a poder realizar distintas c치lculos y an치lisis.

```{r librerias}
library(tidyverse)
library(funModeling)
library(summarytools)
library(scales)
```

## Trabajando con variables categ칩ricas

Con las variables *categ칩ricas,* ya sean *nominales* u *ordinales*, no podemos hacer calculos aritm칠ticos como sumas, promedios y cosas por el estilo. 쯈u칠 podemos hacer? Por ejemplo contar casos.

```{r cate-1, exercise=TRUE}
library(tidyverse) # Limpieza y manipulaci칩n de datos

kiwi_ar %>% 
  count(puesto) # Cuenta la cantidad de casos por puesto
```

Contar casos de una variable, como en el ejemplo anterior que contamos la cantidad de respuestas recibidas para cada puesto, en estad칤stica se llama **Distribuci칩n de Frecuencias**. 쯇or qu칠?

![](https://cdn.memegenerator.es/imagenes/memes/full/29/80/29808033.jpg){width="300"}

En realidad, debe haber un por qu칠, pero podremos sobrevivir sin saberlo.

En ocasiones, algo que permite hacer m치s claras las interpretaciones de los resultados es agregar los porcentajes.

```{r cate-2, exercise=TRUE}
# Tidyverse ya est치 cargado
library(scales) # Es para usar la funci칩n percent() a continuaci칩n  

# Hace click en "Run Code"
kiwi_ar %>% 
  count(puesto) %>% 
  mutate(porcentaje = percent(n / sum(n))) # Toma el valor de la celda en n y lo divide por el total de la columna n
```

Al incorporar el porcentaje en el an치lisis lo que estamos haciendo es agregar, lo que en estad칤stica se llama **Frecuencias Relativas.**

En el data frame tenemos entonces tres posiciones, `Administrativo`, `Analista`, y `HRBP` que no son posiciones jer치rquicas. 쯈u칠 porcentaje del total representan?

Dados que los datos est치n ordenados por jerarqu칤a (쯖칩mo se llaman estas variables?) podemos sumar el porcentaje de `Administrativo` al porcentaje de `Analista`, y ese total, sumarlo a `HRBP`. Usemos la funci칩n `freq()` del paquete `summarytools` para hacerlo f치cilmente.

```{r cate-3, exercise = TRUE}

kiwi_ar %>% 
  select(puesto) %>% 
  freq(report.nas = FALSE)
```

Si vamos sumando los porcentajes de cada fila, *acumul치ndolos* (agregando primero `Administrativo` y `Analista` y siguiendo despu칠s con `HRBP` y as칤 sucesivamente) lo que estamos haciendo es una **Distribuci칩n de Frecuencias Relativas Acumuladas**.

Entonces, 쯤u칠 porcentaje de las respuestas pertenecen a personas en puestos no jer치rquicos?

```{r cate-4}
quiz(
  question("쯈u칠 porcentaje de las respuestas son de personas en posiciones no jer치rquicas (considerando Administrativos, Analistas y HRBP)?",
           answer("10.40%", message = "Ese es el porcentaje de los HRBP"),
           answer("56.39%", message = "Excelente!", correct = T),
           answer("45.99%", message = "Esa es el porcentaje acumulado de Administrativo y Analista. Falta sumar el porcentaje de los HRBP."),
           submit_button = "Enviar respuesta",
           try_again_button = "Intenta de nuevo",
           allow_retry = TRUE
))
```

## Repaso

-   **Distribuci칩n de frecuencias:** Que es el conteo, en este caso, de la cantidad de respuestas recibidas por puesto.

-   **Frecuencias relativas:** Que es el *porcentaje* que representa el conteo sobre el total.

-   **Frecuencia relativas acumuladas:** Que representa el *porcentaje acumulado* de los ingresos de cada trimestre.

## Pr치ctica 1

쯉e puede tomar mate en todas las empresas? Veamos la cantidad de respuestas de la variable `mate` para ver en cu치ntos casos respondieron que s칤 se pod칤a tomar, y cu치ntos respondieron que no. Reemplaz치 los espacios vac칤os seg칰n corresponda al nombre de la funci칩n o de la variable.

```{r cate-5, exercise=TRUE}
kiwi_ar %>% 
  count(_____)
```

```{r cate-5-hint-1}
# Reemplaz치 el espacio vac칤o dentro de la funci칩n count() con el nombre de la variable 'mate'
```

```{r cate-5-hint-2}
kiwi_ar %>% 
  count(mate)
```

![](https://i.pinimg.com/736x/37/55/13/3755137bec08eab75fa7351696803b53.jpg){width="287"}

쯏 qu칠 porcentaje representan de las respuestas? Agrega una columna calculando el porcentaje (frecuencia relativa).

```{r cate-6, exercise=TRUE, exercise.lines = 5}
kiwi_ar %>% 
  ______(____) %>% # Complet치 con la funci칩n y la variable que corresponde
  mutate(porcentaje = round(n/sum(n),2)) # Agrega una columna con los porcentajes redondeando a 2 decimales.
```

```{r cate-6-hint-1}
# Us치 la funci칩n count() para contar la cantidad de respuestas por cada caso
# La variable que queremos analizar se llama 'mate'
```

```{r cate-6-hint-2}
kiwi_ar %>% 
  count(mate) %>% # Complet치 con la funci칩n y la variable que corresponde
  mutate(porcentaje = round(n/sum(n),2)) # Agrega una columna con los porcentajes redondeando a 2 decimales.
```

Calcular la distribuci칩n de frecuencias acumuladas seg칰n la `region`. Reemplaz치 los espacios vac칤os seg칰n corresponda al nombre de la funci칩n o de la variable.

```{r cate-7, exercise=TRUE, exercise.lines = 4}
kiwi_ar %>% 
  select(______) %>% 
  freq(report.nas = FALSE)
```

```{r cate-7-hint-1}
# Reemplaz치 el espacio vac칤o dentro de la funci칩n select() con el nombre de la variable 'region'
```

```{r cate-7-hint-2}
kiwi_ar %>% 
  select(region) %>% 
  freq(report.nas = FALSE)
```

## An치lisis Univariado Variables Categ칩ricas - Visualizaci칩n

Para visualizar una sola variable categ칩rica, las opciones principales son los gr치ficos de **barras** y los gr치ficos de **torta** o de **dona**, con sus respectivas ventajas y desventajas.

## Gr치ficos de barras

Para hacer un gr치fico de barras podemos utilizar una funci칩n la funci칩n de R base `plot()` indicando la variable que queremos visualizar (indicando primero el nombre del data frame despu칠s del signo `$` el nombre de la variable).

```{r catev-1, exercise=TRUE}
# Realizar un gr치fico de barra
plot(kiwi_ar$puesto)
```

Si usamos la misma funci칩n con una variable num칠rica vamos a obtener un gr치fico diferente.

```{r catev-2, exercise=TRUE}
# Realizar un gr치fico de cantidad de personas a cargo
plot(kiwi_ar$sueldo_bruto)
```

En este caso lo que hace R es asignarle un n칰mero de 칤ndice (el n칰mero de la fila) y es lo que grafica en el eje `x` mientras que en el eje `y` asigna el valor de `sueldo_bruto`.

Volvamos a los gr치ficos de barras.

Uno de los paquetes m치s utilizados para hacer visualizaciones es el paquete `ggplot2` que ya viene incorporado dentro de la suite `tidyverse`, o sea que no hace falta instalarlo aparte si ya instalamos previamente `tidyverse`. Hay muchos paquetes m치s para hacer visualizaciones, la ventaja de `ggplot2` es que hay muchos desarrollos y extensiones dise침adas para funcionar con sus funciones, lo cual lo hace un gran punto de partida.

Primero tenemos que "activar" el paquete con la funci칩n `library()`.

```{r catev-3, exercise=TRUE}
# Cargar el paquete con la funci칩n library()
_______(ggplot2)

# Realizar el gr치fico de barras
ggplot(kiwi_ar,             # Primero indicamos el nombre del dataframe
       aes(x = puesto)) +   # Dentro de aes() mapeamos la variable que queremos graficar
  geom_bar()                # Indico el tipo de gr치fico
```

```{r catev-3-hint}
# Cargar el paquete con la funci칩n library()
library(ggplot2)

# Realizar el gr치fico de barras
ggplot(kiwi_ar,             # Primero indicamos el nombre del dataframe
       aes(x = puesto)) +   # Dentro de aes() mapeamos la variable que queremos graficar
  geom_bar()                # Indico el tipo de gr치fico
```

`geom_bar()` requiere que le indiquemos una sola variable. Lo que hace es contar la cantidad de veces (la frecuencia) con la que aparece cada caso, y en funci칩n de la cantidad de veces que aparece cada puesto en el dataset, va aumentando el tama침o de la barra. Para m치s informaci칩n sobre los distintos *geoms* consultar la [documentaci칩n](https://ggplot2.tidyverse.org/) del sitio de `ggplot2` o bien la [gu칤a que confeccionamos](https://docs.google.com/document/d/1JAthc42Hno3tIhvZRrjA02zRCdS8q2uixODCBaZcPJ0/edit?usp=sharing).

```{r catev-4}
quiz(
  question("쯈u칠 pasa si asignamos la variable puesto al eje y?",
           answer("Nada", message = "No pasa nada grave pero algo pasa, prob치 reemplazando x por y en el bloque de c칩digo anterior"),
           answer("Le agarra un virus a la compu y aparezco en la lista de los m치s buscados por la Interpol", message = "Les dije 1 mill칩n de veces que no sean exagerados"),
           answer("El gr치fico 'se da vuelta'", correct = TRUE, message = "Correcto! Los nombres de los puestos aparecen en el eje y (m치s legibles de hecho) y las barras est치n apaisadas"),
         submit_button = "Enviar respuesta",
         try_again_button = "Intenta de nuevo",
         allow_retry = TRUE  
  )
)
```

## Gr치ficos de torta o de dona

Para bien o para mal, los gr치ficos de torta no tienen un *geom* espec칤fico, y si bien en R base hay una funci칩n espec칤fica para hacerlos, requiere un poco de preprocesamiento previo.

En esencia los pasos para hacer un buen gr치fico de torta son los siguientes:

1.  Preparar los datos para que las categor칤as queden ordenadas de mayor a menor seg칰n su frecuencia.

2.  Hacer un gr치fico apilado al 100%

3.  "Doblar" el gr치fico hasta que quede como un gr치fico de torta o dona.

Este ser칤a un gr치fico apilado al 100%

```{r categ-5}
# Preparaci칩n de los datos
puestos <- kiwi_ar %>% 
  select(puesto) %>%    # Seleccionamos la columna tipo universidad
  group_by(puesto) %>%  # Agrupamos los resultados
  summarise (n = n()) %>%         # Contamos la cantidad de casos para cada grupo
  mutate(freq = n/sum(n)) %>%     # Creamos una columna nueva calculando la frecuencia relativa
  arrange(-n)                     # Ordenamos los resultados de mayor a menor

# Calcular los porcentajes acumulados (tope de cada rect치ngulo)
puestos$ymax <- cumsum(puestos$freq)

# Calcula el l칤mite inferior
puestos$ymin <- c(0, head(puestos$ymax, n=-1))

ggplot(puestos, aes(ymax=ymax, ymin=ymin, xmax=4, xmin=3, fill=puesto)) +
  geom_rect()
```

Y ahora lo tenemos que "doblar".

![](https://miro.medium.com/max/900/1*6JHx7caXdrL1SQ9mI3KRuA.jpeg){width="291"})

Los pasos para hacer un gr치fico de dona son los siguientes. Pod칠s copiar el script en tu m치quina para probar el paso a paso.

```{r pie-chart, echo=TRUE}
# Preparaci칩n de los datos
puestos <- kiwi_ar %>% 
  select(puesto) %>%    # Seleccionamos la columna tipo universidad
  group_by(puesto) %>%  # Agrupamos los resultados
  summarise (n = n()) %>%         # Contamos la cantidad de casos para cada grupo
  mutate(freq = n/sum(n)) %>%     # Creamos una columna nueva calculando la frecuencia relativa
  arrange(-n)                     # Ordenamos los resultados de mayor a menor

# Calcular los porcentajes acumulados (tope de cada rect치ngulo)
puestos$ymax <- cumsum(puestos$freq)

# Calcula el l칤mite inferior
puestos$ymin <- c(0, head(puestos$ymax, n=-1))

# Hacemos el gr치fico
ggplot(puestos, aes(ymax=ymax, ymin=ymin, xmax=4, xmin=3, fill=puesto)) +
  geom_rect() +
  coord_polar(theta="y") + # Elimina esta l칤nea de c칩digo para entender lo que hace R.
  xlim(c(2, 4)) + # Prueben eliminando esta l칤nea de c칩digo para hacer un gr치fico de torta
  theme_void() +                             # Cambia est칠tica del gr치fico
  theme(legend.position = "top",            # Cambia la posici칩n de la leyenda
        plot.title.position = "plot") +      # Cambia la posici칩n del t칤tulo  
  labs(title = "Respuestas por puesto",
       fill = "Puesto")

```

![](https://raw.githubusercontent.com/chechoid/dpa-itba/main/PEPA/pie_crocs.jpg){width="355"}

## Trabajando con variables cuantitativas

Con las variables num칠ricas, por otro lado podemos hacer an치lisis mucho m치s diversos que con las variables categ칩ricas. Podemos hacer desde c치lculos aritm칠ticos (sumas, restas, multiplicaciones y divisiones) hasta *c치lculos de resumen estad칤stico* (promedio, mediana, desv칤o est치ndar, etc.).

Dado que las variables cuantitativas pueden a veces tomar valores infinitos, hacer un c치lculo de frecuencias por los valores que tenemos puede ser dif칤cil de interpretar.

Veamos este ejemplo donde tomamos la variable `ajuste_porcentaje` que indica el valor porcentual de aumentos salariales recibidos durante 2020 (el relevamiento de datos se hizo en octubre).

```{r num-1, exercise = TRUE}
# An치lisis cuantitativo no agrupado 
kiwi_ar %>% 
  count(ajuste_porcentaje)
```

Terminamos con una tabla con 68 filas que tiene niveles de detalles poco 칰tiles (una respuesta detallando que el ajuste fue de `12.69%`, dos personos recibieron `12.8%` de aumento por ejemplo). Esto es lo que ocurre cuando tenemos **datos cuantitativos no agrupados**.

En cambio, si armamos categor칤as, con rangos de aumentos, podemos terminar con algo mucho m치s informativo, y 칰til para analizar. A esto le llamaremos an치lisis de **datos cuantitativos agrupados.**

```{r num-2, exercise=TRUE}
kiwi_ar %>% 
  select(rangos_aumentos) %>% 
  freq(report.nas = FALSE)
```

## An치lisis Univariado Variables Cuantitativas - Visualizaci칩n

Antes de meternos con las medidas de resumen estad칤stico, y aprovechando este 칰ltimo concepto de datos cuantitativos agrupados, vamos a plantear algunas posibles visualizaciones.

Primero, realicemos un gr치fico de barras sobre la variable `ajuste_porcentaje`.

```{r num-3, exercise=TRUE}
ggplot(kiwi_ar, aes(x = ajuste_porcentaje)) +
  geom_bar()
```

Hay tantos valores posibles que muchas barras pasan desapercibidas. Probemos graficar los rangos de aumentos.

```{r num-4, exercise=TRUE}
ggplot(kiwi_ar, aes(x = rangos_aumentos)) +
  geom_bar()
```

Esta forma de graficar una variable *cuantitativa* en categor칤as nos sirve para introducir un tipo de gr치fico muy utilizado en Analytics, que es el **histograma**.

A primera vista, el *histograma* parece un gr치fico de barras, con la diferencia que la barra no representa un valor 칰nico (por ejemplo 5), sino un *rango de valores*. (por ejemplo, entre 5 y 10). Ergo, el alto de la barra va a estar dado por la cantidad de casos que caigan dentro de cada rango.

![Ay el arquitecto de Matrix diciendo ergo](https://alchetron.com/cdn/architect-the-matrix-7af001d6-8db4-40d6-8e40-fbf29656e28-resize-750.jpeg ""Ergo"")

De nuevo, hay varias formas de hacer un histograma en R. En R base la forma es la siguiente:

```{r hist-1, exercise = TRUE}
hist(kiwi_ar$ajuste_porcentaje)
```

Y en `ggplot2` la forma de hacerlo es la siguiente:

```{r hist-2, exercise=TRUE}
ggplot(kiwi_ar, aes(x = ajuste_porcentaje)) +
  geom_histogram(bins = 15) # Ajusta la cantidad de barras que van a aparecer en el gr치fico
```

Prueben distintas versiones del histograma cambiando la cantidad de `bins` o incluso borrando todo lo que est치 dentro del par칠ntesis de `geom_histogram()`.

Podemos agregar una capa adicional de informaci칩n a la visualizaci칩n con un gr치fico adicional conocido como **pol칤gono de frecuencia.** Una clave para que este gr치fico funcione bien en conjunto con el histograma es que ambos tengan el mismo valor en `bins`.

```{r freq-1, exercise = TRUE}
ggplot(kiwi_ar, aes(x = ajuste_porcentaje)) +
  geom_histogram(bins = 15) +
  geom_freqpoly(aes(ajuste_porcentaje),  # A침adimos el pol칤gono de frecuencia
                bins = 15)
```

Esta capa extra nos ayuda a identificar de manera m치s clara la **distribuci칩n** de los datos. 쯇or qu칠 es importante conocer la distribuci칩n de los datos? Porque a veces los datos, los c치lculos y las medidas de resumen pueden *esconder* algunos problemas.

![](https://raw.githubusercontent.com/chechoid/dpa-itba/main/PEPA/distribucion.png){width="593"}

Busquen informaci칩n sobre el [Cuarteto de Anscombe](http://ptarra.blogspot.com/2013/05/el-cuarteto-de-anscombe.html) y especialmente del [Datasaurus Dozen](http://www.thefunctionalart.com/2016/08/download-datasaurus-never-trust-summary.html).

## Pr치ctica 2

```{r carga-datos3}
library(funModeling)

percentiles = profiling_num(kiwi_ar$sueldo_bruto)

p05 = percentiles[1,6]
p95 = percentiles[1,10]

kiwi_limpio = kiwi_ar %>% 
  filter(between(sueldo_bruto, p05, p95))
```

Realizar un histograma de la variable `sueldo_bruto`.

```{r hist-4, exercise=TRUE}
ggplot(kiwi_ar, aes(x = _______)) +
  geom_histogram()
```

```{r hist-4-hint-1}
# Coloc치 el nombre de la variable a graficar (sueldo_bruto)
```

```{r hist-4-hint-2}
ggplot(kiwi_ar, aes(x = sueldo_bruto)) +
  geom_histogram()
```

Aqu칤 nos encontramos con el problema de los *outliers*. 쮺u치l es el `sueldo_bruto` m치s alto? 쯏 el m치s bajo?

```{r hist-5, exercise = TRUE}
# Cu치l imaginan que es la funci칩n para calcular el valor m치ximo de una columna
___(kiwi_ar$____)

# Detectar el sueldo bruto m치s bajo
min(_____$sueldo_bruto)
```

```{r hist-5-hint}
# Cu치l imaginan que es la funci칩n para calcular el valor m치ximo de una columna
max(kiwi_ar$sueldo_bruto)

# Detectar el sueldo bruto m치s bajo
min(kiwi_ar$sueldo_bruto)
```

Vemos que tenemos un `sueldo_bruto` de m치s de \$ 2 millones de pesos. En el histograma anterior, tambi칠n podemos identificar otro caso at칤picamente alto, 쯘n qu칠 rango salarial se encuentra?

```{r hist-6}
quiz(
  question(
    "쮼n qu칠 rango salarial encontramos otro outlier o valor at칤pico?",
    answer("Entre $ 250.000 y $ 500.000", message = "Nop, prob치 otra vez"),
    answer("Entre $ 500.000 y $ 1.000.000", correct = TRUE, message = "Excelente! Hay una respuesta de $ 650.000"),
    answer("Entre $ 1.000.000 y $ 1.500.000", message = "Nop, prob치 otra vez"),
    allow_retry = TRUE, 
    submit_button = "Enviar respuesta",
    try_again_button = "Intenta de nuevo"
  )
)
```

Usando un data frame nuevo, llamado `kiwi_limpio` realizar nuevamente el histograma de la variable `sueldo_bruto`.

```{r hist-7, exercise=TRUE}
____(______$________)
```

```{r hist-7-hint-1}
# La funci칩n de R base es hist
# Pon칠 primero el nombre del nuevo data frame y luego la variable sueldo_bruto
```

```{r hist-7-hint-2}
# El nuevo data frame se llama kiwi_limpio
# Record치 poner nombre_dataframe$nombre_variable
```

```{r hist-7-hint-3}
hist(kiwi_limpio$sueldo_bruto
```

## Medidas de resumen estad칤stico

La estad칤stica es una disciplina que suele trabajar con *muestras*. Con cierta frecuencia, nos encontramos que no podemos analizar a todos los empleados porque ser칤a muy costoso en tiempo y recursos, o bien porque nos interesa segmentar el an치lisis sobre alguna muestra en particular.

Sobre esas muestras hacemos *inferencias* sobre la poblaci칩n que estamos analizando.

En nuestro caso, la **poblaci칩n** de la encuesta es de `r nrow(kiwi_ar)` casos. De ese total, podr칤amos pensar en las siguientes **muestras** de datos por ejemplo:

-   Personas en posiciones de Gerente.

-   Conjunto de mujeres en posiciones de liderazgo.

-   Personas que recibieron m치s de un aumento salarial.

-   etc..

```{r est-1, echo=TRUE}
# Personas en posiciones de Gerente
kiwi_ar %>% 
  filter(puesto == "Gerente") %>% 
  count(puesto)

# Conjunto de mujeres en posiciones de liderazgo
kiwi_ar %>% 
  filter(es_lider == 1, genero == "Femenino") %>% 
  count(puesto)

# Personas que recibieron m치s de un aumento salarial
kiwi_ar %>% 
  filter(ajuste %in% c("2 ajustes", "3 o m치s ajustes")) %>% 
  count(ajuste)
```

Todo esto es para hacer una introducci칩n al **promedio**, denominado tambi칠n **media muestral**.

```{r carga-datos-4}
df_edad <- read.csv("edades.csv")
edades <- df_edad %>% select(Edad) %>% pull()
edades <- sort(edades)
```

## Promedio

El **promedio** o **media muestral** es una medida de tendencia central. Esto quiere decir que ese valor ser치 el m치s representativo del conjunto de datos (o al menos eso se espera). Para hacer algunos ejemplos vamos a usar las edades de los alumnos de un curso.

```{r prom-1, exercise = TRUE}
edades
```

Como explica Walter Sosa Escudero, si todas estas personas entraran en un aula, y se fundieran en uno solo, la edad que tendr칤a esa persona que representa a todos, ser칤a la *edad promedio*.

La funci칩n para calcular la media muestral o promedio se llama `mean()`.

```{r prom-2, exercise=TRUE}
____(edades)
```

```{r prom-2-hint}
mean(edades)
```

Como ya saben, el promedio es sensible a los valores extremos. Creen un nuevo vector llamado `edades_2` y modifiquen el primer valor del vector y pongan 120 y vuelvan a calcular el promedio.

```{r prom-3, exercise=TRUE}
# Crear un nuevo vector con los valores de edad
edades_2 <- edades

# Modificar el primer elemento y poner 120
edades_2[1] <- ____
edades_2

# Calcular nuevo promedio del vector edades_2
____(_________)
```

```{r prom-3-hint}
# Crear un nuevo vector con los valores de edad
edades_2 <- edades

# Modificar el primer elemento y poner 120
edades_2[1] <- 120
edades_2

# Calcular nuevo promedio del vector edades_2
mean(edades_2)
```

```{r promedio-2}
# Crear un nuevo vector con los valores de edad
edades_2 <- edades

# Modificar el primer elemento y poner 120
edades_2[1] <- 120
```

Podemos apreciar que el promedio pas칩 de `r round(mean(edades),2)` en el primer vector, y con el segundo vector cambi칩 a `r round(mean(edades_2),2)` .

Algo muuuuy importante en estad칤stica es el concepto de *distancia*. Una caracter칤stica del promedio es que es el valor que tiene la menor distancia a todos los puntos. Se los dejo picando porque este concepto va a ser 칰til para entender algo m치s adelante cuando hablemos de regresiones lineales.

Prueben calculando las diferencias entre los datos contra el promedio, y con otros n칰meros al azar.

```{r mean-3, exercise = TRUE}
# Guardar el promedio edades
promedio_edad <- mean(edades)

# Grafiquemos las edades para cada persona
ggplot(df_edad, aes(x = Edad, y = Inicial)) +
  geom_point(size = 3) +
  geom_vline(xintercept = promedio_edad, size = 1, color = "red")
```

## Mediana y cuantiles

As칤 como el promedio es una medida de *tendencia central*, al igual que la **mediana**. Los **cuantiles** son medidas **de orden** (por ende los \*cuartiles o deciles\* tambi칠n lo son). Lo que hacen estas medidas es ordenar los datos de mayor a menor, y nos indican cu치l es el valor que est치 en:

Internamente, para calcular la mediana, se ordenan los valores de mayor a menor y se busca el valor que est치 en la mitad de la variable.

![](https://karatedolam.files.wordpress.com/2011/07/karate_tameshiwari.jpg){width="196"}

Si tenemos una cantidad de datos impares, el valor que est치 justo a la mitad (dejando la misma cantidad de casos de un lado y del otro) esa ser치 la mediana.

Si tenemos una cantidad par de datos, para calcular la mediana, hacemos un promedio entre los valores que est치n en la mitad de los valores.

Nuestro vector `edades` tiene 11 elementos. 쮺u치l ser치 la mediana?

```{r med-1, exercise = TRUE}
# Correr el script y pensar cu치l ser치 la mediana
edades

# Verificar calculando la mediana con la funci칩n median
median(______)
```

```{r med-1-hint}
# Correr el script y pensar cu치l ser치 la mediana
edades

# Verificar calculando la mediana con la funci칩n median
median(edades)
```

Creemos un nuevo vector llamado `edades_3` agregando un nuevo elemento y calcular la mediana usando la funci칩n `median()`.

```{r med-2, exercise = TRUE}
#Crear un nuevo vector
edades_3 <- edades

# Agregar un nuevo valor
edades_3[12] <- 50

# Calcular la mediana
_____(edades_3)
```

```{r med-2-hint}
#Crear un nuevo vector
edades_3 <- edades

# Agregar un nuevo valor
edades_3[12] <- 50

# Calcular la mediana
median(edades_3)
```

Es bien sabido que una propiedad de la mediana es que no se ve afectada por los valores extremos.

```{r med-3, exercise = TRUE}
#Crear un nuevo vector
edades_4 <- edades

# Modificar el primer valor con un valor alto
edades_4[1] <- 150

# Calcular la mediana
median(edades_4)

```

Hay cuantiles que tienen *"nombres propios"**.*** Por ejemplo,

Los **cuartiles** que dividen a la variable en 4 partes (en el 25%, 50% y 75% de los datos.

Los **quintiles** que dividen a la variable en 5 partes. (en el 20%, 40%, 60%, 80% de los datos).

Los **deciles** que dividen a la variable en 10 partes. (en el 10%, 20%, 30%, 40%, 50%, 60%, 70%, 80%, 90% de los datos).

En la pr치ctica se suelen usar con mucha frecuencia los **cuartiles**, y para algunas medidas de control de los modelos predictivos se controlan resultados usando los **deciles.**

Usemos el data frame `kiwi_ar`. Una forma de r치pidamente los *cuartiles* es usando la funci칩n `summary()`. Hagamos el c치lculo sobre la variable `edad`.

```{r q1, exercise=TRUE}
summary(kiwi_ar$edad)
```

La funci칩n `summary()` nos permite ver r치pidamente:

-   Los valores **m칤nimo** y **m치ximo**.

-   El **primer** y **tercer cuartil**.

-   La **mediana** (median).

-   El **promedio** (mean).

Si queremos definir los *quintiles* o los *deciles*, tenemos que hacerlo manualmente con la funci칩n `quantile()`.

```{r q2, exercise = TRUE}
# Calcular los deciles
quantile(kiwi_ar$edad, c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8))

```

Volviendo a los **cuartiles**, entre el *primer cuartil* y el *tercer cuartil* se encuentran la mitad de los datos 游뱚. En alg칰n momento de la historia, alg칰n estad칤stico o estad칤stica muy fum칩n o fumona se le ocurri칩 restar al valor del 3er cuartil el valor del 1er cuartil y a eso lo llam칩 **Rango Intercuartil** (se lo conoce con las siglas IQR en ingl칠s).

Hagamos la prueba con la variable `edad` del data frame `kiwi_ar`.

```{r q3, exercise = TRUE}
# Calcular el primer cuartil
q1 <- quantile(kiwi_ar$edad, 0.25)

# Calcular el tercer cuartil
q3 <- ________(______$___ , ___)

# Calcular el rango intercuartil
rango_ic <- ___ - ___

rango_ic
```

Ya s칠, se est치n preguntando *"쯇ara qu칠 carajo me sirve todo esto?"*. El **rango intercuartil** es un paso necesario para determinar si un valor **es un outlier o no** 游뱚游뱚游뱚**.**

Si a ese *rango intercuartil* lo multiplico por 1.5, y a eso se lo restamos al *primer cuartil* obtenemos el l칤mite inferior para determinar los outliers, y si ese resultado (IQR x 1.5) se lo sumamos al *tercer cuartil* obtenemos el l칤mite superior para detectar los outliers.

```{r q4, exercise=TRUE}
# Calcular el primer cuartil
q1 <- quantile(kiwi_ar$edad, 0.25)

# Calcular el tercer cuartil
q3 <- quantile(kiwi_ar$edad, 0.75)

# Calcular el rango intercuartil
rango_ic <- q3 - q1

# Calcular l칤mite inferior
lim_inf <- q1 - rango_ic * 1.5

# Calcular l칤mite superior
lim_sup <- _______________ * 1.5

# Ver ambos resultados
lim_inf
lim_sup
```

```{r q4-hint}
# Calcular el primer cuartil
q1 <- quantile(kiwi_ar$edad, 0.25)

# Calcular el tercer cuartil
q3 <- quantile(kiwi_ar$edad, 0.75)

# Calcular el rango intercuartil
rango_ic <- q3 - q1

# Calcular l칤mite inferior
lim_inf <- q1 - rango_ic * 1.5

# Calcular l칤mite superior
lim_sup <- q3 - rango_ic * 1.5

# Ver ambos resultados
lim_inf
lim_sup
```

Todo esto fue una excusa para introducir uno de mis gr치ficos favoritos: los **boxplots**.

![](https://raw.githubusercontent.com/chechoid/dpa-itba/main/PEPA/boxplot.png){width="513"}

Hagamos un ejemplo con la variable `edad` del data frame `kiwi_ar`.

```{r q5, exercise = TRUE}
ggplot(kiwi_ar, aes(x = edad)) +
  geom_boxplot()
```

En el gr치fico podemos apreciar que hay 3 *outliers* por encima de los 54 a침os aproximadamente.

Algo interesante de los boxplots, es que tambi칠n nos da una idea de la distribuci칩n de los datos.

```{r q6, out.width="70%"}
ggplot(kiwi_ar, aes(x = edad)) +
  geom_histogram()

ggplot(kiwi_ar, aes(x = edad)) +
  geom_boxplot()

```

El paquete `funModeling` tiene algunas funciones muy interesantes. Prueben la funci칩n `profiling_num()` sobre la variable `edad`.

```{r q7, exercise = TRUE}
# install.packages("funModeling") # Por si es necesario

# Cargar librer칤a
library(funModeling)

# Probar la funci칩n profiling_num()
profiling_num(kiwi_ar$edad)
```

## Medidas de dispersi칩n

Las medidas de dispersi칩n son muy 칰tiles para saber qu칠 tan lejos est치n los datos del promedio por ejemplo, y concordantemente, *qu칠 tan representativo es ese promedio y si est치 siendo influenciado o no por valores extremos*.

![Ay el arquitecto de Matrix diciendo "concordantemente"](https://alchetron.com/cdn/architect-the-matrix-7af001d6-8db4-40d6-8e40-fbf29656e28-resize-750.jpeg)

Dos m칠tricas que nos sirven para calcular la dispersi칩n de los datos son la **varianza** y el **desv칤o est치ndar**. El *desv칤o est치ndar* es de hecho, la ra칤z cuadrada de la varianza, y tiene la particularidad que tiene la misma unidad de medida que la variable. O sea qu칠:

-   Si calculo el desv칤o est치ndar de una variable en pesos argentinos, el desv칤o estar치 expresado en pesos.

-   Si calculo el desv칤o est치ndar de una variable en cent칤metros, el desv칤o est치ndar estar치 expresado en cent칤metros.

-   Si calculo el desv칤o est치ndar de una variable en a침os, el desv칤o est치ndar estar치 expresado en a침os.

![](https://cdn.memegenerator.es/imagenes/memes/full/32/38/32381633.jpg)

Calculemos la varianza y el desv칤o est치ndar de la variable `edad` en el data frame `kiwi_ar`.

```{r dis-1, exercise=TRUE}
# Calcular la varianza
___(kiwi_ar$edad)

# Calcular el desv칤o est치ndar
__(kiwi_ar$edad)
```

```{r dis-1-hint-1}
# Busquen en google. Aprender a buscar soluciones en google tambi칠n es parte del aprendizaje para programar
```

```{r dis-1-hint-2}
# Calcular la varianza
___(kiwi_ar$edad)

# Calcular el desv칤o est치ndar
__(kiwi_ar$edad)
```

Otra medida que se puede calcular es el **coeficiente de variaci칩n**, que es una medida de la variabilidad de una variable seg칰n el tama침o de la muestra (ver en [Wikipedia](https://es.wikipedia.org/wiki/Coeficiente_de_variaci%C3%B3n)).

Su c치lculo es muy simple. Surge de dividir el *desv칤o est치ndar por el promedio*.

```{r dis-2, exercise=TRUE}
# Calcular el desv칤o est치ndar de la variable edad
desvio <- sd(kiwi_ar$edad)

# Calcular el promedio de la variable edad
promedio <- mean(kiwi_ar$edad)

# Calcular el coeficiente de variaci칩n
coef_var <- desvio / promedio

coef_var
```

## Estandarizar o normalizar variables

쮺omo hacemos para analizar una relaci칩n entre un sueldo que est치 expresado en miles de pesos y la experiencia que est치 expresada en a침os? O llev치ndolo a otro dominio, analizar la relaci칩n entre el peso y la altura que tienen unidades de medida diferentes (kilos y cent칤metros).

Para eso existe la **estandarizaci칩n de variables**, tambi칠n conocida como **normalizaci칩n de variables**, y en ocasiones tambi칠n **z-score**. Esto lo vamos a ver m치s en profundidad cuando hagamos an치lisis de dos muestras, pero como su c치lculo involucra al *promedio* y al *desv칤o est치ndar* nos pareci칩 interesante hacer un anticipo del tema, para luego m치s adelante hablar de correlaciones por ejemplo.

La f칩rmula para normalizar una variable es la siguiente:

![](https://wikimedia.org/api/rest_v1/media/math/render/svg/1eda92e3a28b3a7d693348c1b9dd871e5baec300)

Donde:

-   $x$ es el valor de cada observaci칩n

-   $\bar{a}$ es la media muestral

-   $s$ es el desv칤o est치ndar de la muesta.

O sea que para valor de la variable R le va a restar a cada caso el promedio, y luego dividir al valor por el desv칤o est치ndar.

Veamos nuevamente el vector `edades`.

```{r z1, exercise=TRUE}
# Correr el script
edades

# Hacer un summary de edades
summary(edades)
```

Ahora veamos los valores *estandarizados*.

```{r z2, exercise=TRUE}
# Correr el script
scale(edades, center= TRUE, scale=TRUE)
```

```{r z3, exercise=TRUE}
# Guardar los valores estandarizados en un objeto
z_edad <- scale(edades, center= TRUE, scale=TRUE)

# Hacer un summary de este nuevo objeto
summary(z_edad)
```

M치s adelante retomamos el tema, por ahora lo dejamos ac치.

## Pr치ctica 3

Calcular el promedio, la mediana y el desv칤o est치ndar de la variable `sueldo_bruto` del data frame `kiwi_ar`.

```{r desc-1, exercise=TRUE, exercise.lines=10}
# Calcular el promedio
___(kiwi_ar$sueldo_bruto)

# Calcular la mediana
____(______$_______)

# Calcular el desv칤o est치ndar
sd(____$_____)
```

```{r des-1-hint-1}
# La funci칩n para calcular el promedio es mean

# La funci칩n para calcular la mediana se llama median. Poner primero el nombre del data frame y luego el de la columna.

# Poner el nombre del data frame kiwi_ar y luego el de la columna sueldo_bruto
```

```{r des-2-hint-2}
# Calcular el promedio
mean(kiwi_ar$sueldo_bruto)

# Calcular la mediana
median(kiwi_ar$sueldo_bruto)

# Calcular el desv칤o est치ndar
sd(kiwi_ar$sueldo_bruto)
```

Otra alternativa para calcular estos resultados es usando la secuencias de `tidyverse`.

```{r des-3, exercise=TRUE}
kiwi_ar %>% 
  select(sueldo_bruto) %>% 
  summarise(promedio = mean(sueldo_bruto),
            mediana = median(sueldo_bruto),
            desvio = sd(sueldo_bruto))
```

Realizar un histograma de la variable `sueldo_bruto`. 쯇or qu칠 sale as칤?

```{r des-4, exercise = TRUE}
# Realizar un histograma de sueldo_bruto
ggplot(_____, aes(x  = sueldo_bruto)) +
  geom_______(bins = 20)
```

```{r des-4-hint-1}
# Poner el nombre del data frame kiwi_ar

# Para hacer un histograma necesitamos usar geom_histogram()
```

```{r des-4-hint-2}
# Realizar un histograma de sueldo_bruto
ggplot(kiwi_ar, aes(x  = sueldo_bruto)) +
  geom_histogram(bins = 20)
```

Ahora crear un data frame nuevo, llamado `kiwi_limpio` filtrando todo lo que est칠 por debajo del *percentil 5* y todo lo que est칠 por encima del *percentil 95*.

```{r des-5, exercise = TRUE, exercise.lines = 22}
# Calcular el valor para el percentil 5
p5 <- quantile(kiwi_ar$sueldo_bruto, 0.05)
p5

# Calcular el valor para el percentil 95
p95 <- _______(_______$__________, 0.95)
p95

# Filtrar los sueldos por debajo y por encima de los percentiles 5 y 95 guard치ndolos en un nuevo data frame
kiwi_limpio <- kiwi_ar %>% 
  filter(between(            # Filtra los casos que est칠n dentro de los l칤mites
    sueldo_bruto,            # Columna para filtrar
    p5,                      # L칤mite inferior
    p95                      # L칤mite superior
  ))

# Realizar un histograma de sueldo_bruto
ggplot(kiwi_limpio, aes(x  = __________)) +
  geom_histogram(bins = 20)
```

```{r des-5-hint-1}
# Utilizar la f칩rmula quantile y luego indicar el nombre del data frame y de la columna

# Asignar al eje x la variable sueldo_bruto
```

```{r des-5-hint-2}
# Calcular el valor para el percentil 5
p5 <- quantile(kiwi_ar$sueldo_bruto, 0.05)
p5

# Calcular el valor para el percentil 95
p95 <- quantile(kiwi_ar$sueldo_bruto, 0.95)
p95

# Filtrar los sueldos por debajo y por encima de los percentiles 5 y 95 guard치ndolos en un nuevo data frame
kiwi_limpio <- kiwi_ar %>% 
  filter(between(            # Filtra los casos que est칠n dentro de los l칤mites
    sueldo_bruto,            # Columna para filtrar
    p5,                      # L칤mite inferior
    p95                      # L칤mite superior
  ))

# Realizar un histograma de sueldo_bruto
ggplot(kiwi_limpio, aes(x  = sueldo_bruto)) +
  geom_histogram(bins = 20)
```

Los data frames `kiwi_ar` y `kiwi_limpio` est치n almacenados en memoria. Realizar un boxplot de la columna `sueldo_bruto` para ambos datasets. 쯈u칠 interpretaci칩n hacen de los resultados?

```{r des-6, exercise = TRUE}
# Realizar un boxplot para el data frame kiwi_ar
ggplot(_____, aes(x = sueldo_bruto)) +
  geom_______()

# Realizar un boxplot para el data frame kiwi_limpio
ggplot(kiwi_limpio, __________)) +
    geom_boxplot()
```

```{r des-6-hint-1}
# Reemplazar el primer espacio vac칤o por el nombre del data frame
# Para hacer un boxplot necesit치s usar geom_boxplot()

# Hay que asignar columna sueldo_bruto al eje x dentro de aes()
# Ten칠 cuidado con los par칠ntisis al final de la primera l칤nea del c칩digo
```

```{r des-6-solution}
# Realizar un boxplot para el data frame kiwi_ar
ggplot(kiwi_ar, aes(x = sueldo_bruto)) +
  geom_boxplot()

# Realizar un boxplot para el data frame kiwi_limpio
ggplot(kiwi_limpio, aes(x = sueldo_bruto)) +
    geom_boxplot()
```

Por 칰ltimo, graficar un boxplot usando el data frame `kiwi_limpio` mapeando en el eje `x` el `puesto`, y en el eje `y` el `sueldo_bruto`. 쯈u칠 interpretaci칩n hacen de los resultados?

```{r des-7, exercise=TRUE}
ggplot(kiwi_limpio, aes(x = puesto, y = sueldo_bruto)) +
    geom_boxplot()
```
